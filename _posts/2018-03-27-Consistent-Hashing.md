---
layout: post
title: 一致性哈希算法
categories: 算法
description: 分布式
keywords: 一致性哈希算法
---

## 场景描述

假设有三台缓存服务器用于缓存图片，现在有三万张图片需要缓存，三台服务器来平摊，也就是每台1万张左右，如果是没有任何规律的平摊，当我们需要访问某个缓存项时，则需要遍历三台服务器，这样效率是很低的。

此时我们可以采用对缓存项的键进行哈希，将哈希后的结果对服务器的数量取模，通过取模后的结果来决定缓存到哪台服务器。

假设图片名称不重复，则可以采用下面的公式：

**hash（图片名称）% N**

N为服务器数量。

因为图片名称是不重复的，所以对同一个名称做哈希，结果应该是一直不变的，如果有3台服务器，对3取余的结果只可能是0、1、2，一共3个值，正好与服务器的数量相对应。
如果取余为0，则缓存到0号服务器上，以此类推。

如果想访问某张图片，采用上面的公式即可计算出图片所在的服务器。

但这种方法是有缺陷的，如果想要增加一台服务器，那么所有缓存的位置都要发生改变，同理一台服务器出现故障，也会造成大量缓存失效，导致后台服务器承受巨大的压力。

这时使用**一致性哈希算法**就可以解决这个问题。

## 一致性哈希算法的基本概念

其实一致性哈希算法也是使用取模的方式，不过刚才的是对服务器的数量进行取模，而一致性哈希算法是对2^32取模。

首先，把2^32想象成一个圆，就像钟表一样，钟表的圆可以理解成由60个点组成的圆，而此处我们把这个圆想象成2^32个点组成的圆，示意图如下：

![](/images/blog/2018-03-27-Consistent-Hashing/Consistent_Hashing_001.png)

圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推2、3、4......直到2^32-1，也就是0点左侧的第一个点代表2^32-1。

我们把这个由2^32个点组成的圆环成为hash环。

现在假设我们有三台服务器，我们使用它们各自的IP地址进行哈希计算，使用哈希结果对2^32取模，公式如下：

**hash（服务器地址）% 2^32**

通过上述公式计算出的结果一定是0到2^32-1之间的一个整数，我们就用这个整数代表服务器A，既然这个整数处于0到2^32之间，那么上图的hash环上必定有一个点与这个整数对应，也就是将服务器A映射到这个环上，如下图所示：

![](/images/blog/2018-03-27-Consistent-Hashing/Consistent_Hashing_002.png)

同理服务器B与服务器C也可以映射到hash环上，如下图所示：

![](/images/blog/2018-03-27-Consistent-Hashing/Consistent_Hashing_003.png)

既然服务器已经映射到hash环上了，那么我们也将需要缓存的对象也映射到hash环上。

使用公式：

**hash（图片名称）% 2^32**

如下图所示：

黄色代表图片。

![](/images/blog/2018-03-27-Consistent-Hashing/Consistent_Hashing_004.png)

我们从图片的位置开始，沿顺时针方向遇到的第一个服务器是服务器A，那么图片就会被缓存到服务器A上。

![](/images/blog/2018-03-27-Consistent-Hashing/Consistent_Hashing_005.png)

这就是**一致性哈希算法**，想判断一个对象应该被缓存到哪台服务器上，就将服务器和被缓存对象都映射到hash环上，从被缓存对象出发，沿顺时针方向遇到的第一个服务器就是将要缓存到的服务器。

因为被缓存对象与服务器的hash值是固定的，所以在服务器数量不变的情况下，一张图片必定会被缓存到固定的服务器上，所以当下次想要访问这张图片时，使用相同的算法进行计算即可找到对应的服务器，从而找到图片。

刚才是一张图片的示例，假设有4张图片，示意图如下：

![](/images/blog/2018-03-27-Consistent-Hashing/Consistent_Hashing_006.png)

## 一致性哈希算法的优点

假设服务器B出现了故障，需要移除，那么我们将上图中的服务器B从hash环上移除即可，移除后的示意图如下：

![](/images/blog/2018-03-27-Consistent-Hashing/Consistent_Hashing_007.png)

服务器B未移除时，图片3应该被缓存到服务器B中，当服务器B移除后，按照之前的一致性哈希算法规则，图片3应该被缓存到服务器C中，因为从图片3的位置出发，沿顺时针遇到的第一个服务器就是服务器C，也就是说当服务器B出现故障时，图片3的位置会发生改变。

![](/images/blog/2018-03-27-Consistent-Hashing/Consistent_Hashing_008.png)

图片4仍然会被缓存到服务器C中，图片1和2仍然会被缓存到服务器A中，这与服务器B移除之前没有区别，这就是一致性哈希算法的优点。之前的hash算法当服务器数量发生改变时所有的缓存都会失效，而一致性哈希算法当服务器数量发生改变时只会有部分缓存失效。

## hash环的偏斜

理想状态下，3台服务器应该是均匀的映射到hash环上，如下所示：

![](/images/blog/2018-03-27-Consistent-Hashing/Consistent_Hashing_009.png)

但在实际情况下，可能是下面的样子：

![](/images/blog/2018-03-27-Consistent-Hashing/Consistent_Hashing_010.png)

这种情况下会导致被缓存的对象大部分集中在某一台服务器上，如下图所示：

![](/images/blog/2018-03-27-Consistent-Hashing/Consistent_Hashing_011.png)

此时如果服务器A出现故障，也会导致大部分缓存失效。

这种情况称之为hash环的偏斜。一致性hash算法中使用“虚拟节点”来解决这个问题。

## 虚拟节点

当hash环出现偏斜后会出现缓存分布不均衡的情况。

此时真实的服务器资源只有3台，而我们可以通过将现有的物理节点通过虚拟技术复制出来，就可以凭空多出许多服务器，从而避免hash环的偏斜。

这些由实际节点虚拟复制出来的节点被称为“虚拟节点”。

加入虚拟节点后的hash环如下所示：

![](/images/blog/2018-03-27-Consistent-Hashing/Consistent_Hashing_012.png)

一个实际节点可以对应多个虚拟节点。

> 参考链接：http://www.zsythink.net/archives/1182

> 声明：本站采用开放的[知识共享署名-非商业性使用-相同方式共享 许可协议](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh)进行许可。
