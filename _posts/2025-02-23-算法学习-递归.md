---
layout: post
title: 2025-02-23-算法学习-递归
categories: 算法
description: 递归
keywords: 递归
---

## 递归解题三部曲

何为递归？程序反复调用自身即是递归。

我自己在刚开始解决递归问题的时候，总是会去纠结这一层函数做了什么，它调用自身后的下一层函数又做了什么…然后就会觉得实现一个递归解法十分复杂，根本就无从下手。

相信很多初学者和我一样，这是一个思维误区，一定要走出来。既然递归是一个反复调用自身的过程，这就说明它每一级的功能都是一样的，因此我们只需要关注一级递归的解决过程即可。

![](https://github.com/machangchang/machangchang.github.io/blob/master/images/blog/hWr1UK.png)

如上图所示，我们需要关心的主要是以下三点：

整个递归的终止条件。
一级递归需要做什么？
应该返回给上一级的返回值是什么？
因此，也就有了我们解递归题的三部曲：

找整个递归的终止条件：递归应该在什么时候结束？
找返回值：应该给上一级返回什么信息？
本级递归应该做什么：在这一级递归中，应该完成什么任务？
一定要理解这3步，这就是以后递归秒杀算法题的依据和思路。

但这么说好像很空，我们来以题目作为例子，看看怎么套这个模版，相信3道题下来，你就能慢慢理解这个模版。之后再解这种套路递归题都能直接秒了。

## 例1：求二叉树的最大深度

先看一道简单的Leetcode题目： Leetcode 104. 二叉树的最大深度

题目很简单，求二叉树的最大深度，那么直接套递归解题三部曲模版：

找终止条件。 什么情况下递归结束？当然是树为空的时候，此时树的深度为0，递归就结束了。
找返回值。 应该返回什么？题目求的是树的最大深度，我们需要从每一级得到的信息自然是当前这一级对应的树的最大深度，因此我们的返回值应该是当前树的最大深度，这一步可以结合第三步来看。
本级递归应该做什么。 首先，还是强调要走出之前的思维误区，递归后我们眼里的树一定是这个样子的，看下图。此时就三个节点：root、root.left、root.right，其中根据第二步，root.left和root.right分别记录的是root的左右子树的最大深度。那么本级递归应该做什么就很明确了，自然就是在root的左右子树中选择较大的一个，再加上1就是以root为根的子树的最大深度了，然后再返回这个深度即可。

![](https://github.com/machangchang/machangchang.github.io/blob/master/images/blog/hWr724.png)


