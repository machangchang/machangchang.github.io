---
layout: post
title: Java 移位运算符
categories: Java
description: Java
keywords: Java
---

Java 中的移位运算符

## 1、左移运算符：<<

十进制数733183670，转换成二进制在计算机中的表示如下：

![](/images/blog/2019-04-29-Shift/Shift_001.jpg)

value << 1，左移1位。

![](/images/blog/2019-04-29-Shift/Shift_002.jpg)

左移1位后换算成十进制的值为：1466367340，刚好是733183670的两倍， 有些人在乘2操作时喜欢用左移运算符来替代。

左移8位看一下：

![](/images/blog/2019-04-29-Shift/Shift_003.jpg)

左移8位后变成了十进制的值为：-1283541504，移动8位后，由于首位变成了1，也就是说成了负数，在使用中要考虑变成负数的情况。

根据这个规则，左移32位后，右边补上32个0值是不是就变成了十进制的0了？答案是NO，当int类型进行左移操作时，左移位数大于等于32位操作时，会先求余（%）后再进行左移操作。也就是说左移32位相当于不进行移位操作，左移40位相当于左移8位（40%32=8）。当long类型进行左移操作时，long类型在二进制中的体现是64位的，因此求余操作的基数也变成了64，也就是说左移64位相当于没有移位，左移72位相当于左移8位（72%64=8）。

综上所述：左移 << 其实很简单，也就是说丢弃左边指定位数，右边补0。

## 2、右移运算符：>>

还是这个数：733183670。

![](/images/blog/2019-04-29-Shift/Shift_004.jpg)

右移1位。

![](/images/blog/2019-04-29-Shift/Shift_005.jpg)

右移1位后换算成十进制的值为：366591835，刚好是733183670的1半， 有些人在除2操作时喜欢用右移运算符来替代

右移8位看一下。

![](/images/blog/2019-04-29-Shift/Shift_006.jpg)

我们再来看看负数的右移运算，如图，负数intValue：-733183670的二进制表现如下图：

![](/images/blog/2019-04-29-Shift/Shift_007.jpg)

右移8位，intValue >> 8。

![](/images/blog/2019-04-29-Shift/Shift_008.jpg)

综上所述：右移运算符>>的运算规则也很简单，丢弃右边指定位数，左边补上符号位。

## 3、无符号右移运算符：>>>

无符号右移运算符>>>和右移运算符>>是一样的，只不过右移时左边是补上符号位，而无符号右移运算符是补上0，也就是说，对于正数移位来说等同于：>>，负数通过此移位运算符能移位成正数。以-733183670>>>8为例来画一下图。

![](/images/blog/2019-04-29-Shift/Shift_009.jpg)

无符号右移运算符>>的运算规则也很简单，丢弃右边指定位数，左边补上0。

> 参考链接：https://zhuanlan.zhihu.com/p/30108890

> 声明：本站采用开放的[知识共享署名-非商业性使用-相同方式共享 许可协议](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh)进行许可。
