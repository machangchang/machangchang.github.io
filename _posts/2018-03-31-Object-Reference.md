---
layout: post
title: Java对象及其引用
categories: Java
description: Java
keywords: Java
---

我们先假设有一个名为Vehicle的类，一般创建对象的方法如下：

**Vehicle veh1 = new Vehicle();**

它其实包含了四个过程：

1）右边的“new Vehicle”，是以Vehicle类为模板，在堆空间里创建一个Vehicle类对象（也简称为Vehicle对象）。

2）末尾的()意味着，在对象创建后，立即调用Vehicle类的构造函数，对刚生成的对象进行初始化。构造函数是肯定有的。如果你没写，Java会给你补上一个默认的构造函数。

3）左边的“Vehicle veh 1”创建了一个Vehicle类引用变量。所谓Vehicle类引用，就是以后可以用来指向Vehicle对象的对象引用。

4）“=”操作符使对象引用指向刚创建的那个Vehicle对象。

我们可以把这条语句拆成两部分：

```java
Vehicle veh1;
veh1 = new Vehicle();
```

效果是一样的。这样写，就比较清楚了，有两个实体：一是对象引用变量，一是对象本身。

在堆空间里创建的实体，与在数据段以及栈空间里创建的实体不同。尽管它们也是确确实实存在的实体，但是，我们看不见，也摸不着。不仅如此，我们仔细研究一下第二句，找找刚创建的对象叫什么名字？有人说，它叫“Vehicle”。不对，“Vehicle”是类（对象的创建模板）的名字。

 一个Vehicle类可以据此创建出无数个对象，这些对象不可能全叫“Vehicle”。 对象连名都没有，没法直接访问它。我们只能通过对象引用来间接访问对象。
      
 为了形象地说明对象、引用及它们之间的关系，可以做一个或许不很妥当的比喻。对象好比是一只很大的气球，大到我们抓不住它。引用变量是一根绳， 可以用来系汽球。

如果只执行了第一条语句，还没执行第二条，此时创建的引用变量veh1还没指向任何一个对象，它的值是null。引用变量可以指向某个对象，或者为null。它是一根绳，一根还没有系上任何一个汽球的绳。执行了第二句后，一只新汽球做出来了，并被系在veh1这根绳上。我们抓住这根绳，就等于抓住了那只汽球。

再来一句：

**Vehicle veh2;**

就又做了一根绳，还没系上汽球。如果再加一句：

**veh2 = veh1;**

系上了。这里，发生了复制行为。但是，要说明的是，对象本身并没有被复制，被复制的只是对象引用。结果是，veh2也指向了veh1所指向的对象。两根绳系的是同一只汽球。

如果用下句再创建一个对象：

**veh2 = new Vehicle();**

则引用变量veh2改为指向第二个对象。

从以上叙述再推演下去，我们可以获得以下结论：

（1）一个对象引用可以指向0个或1个对象（一根绳子可以不系汽球，也可以系一个汽球）；

（2）一个对象可以有N个引用指向它（可以有N条绳子系住一个汽球）。

 如果再来下面语句：
 
 **veh1 = veh2;**
 
按上面的推断，veh1也指向了第二个对象。这个没问题。问题是第一个对象呢？没有一条绳子系住它，它飞了。多数书里说，它被Java的垃圾回收机制回收了。这不确切。正确地说，它已成为垃圾回收机制的处理对象。至于什么时候真正被回收，那要看垃圾回收机制的心情了。

先看下面的程序：

```java
StringBuffer s;
s = new StringBuffer("Hello World!");
```

第一个语句仅为引用(reference)分配了空间，而第二个语句则通过调用类(StringBuffer)的构造函数StringBuffer(String str)为类生成了一个实例（或称为对象）。这两个操作被完成后，对象的内容则可通过s进行访问——在Java里都是通过引用来操纵对象的。

Java对象和引用的关系可以说是互相关联，却又彼此独立。彼此独立主要表现在：引用是可以改变的，它可以指向别的对象，譬如上面的s，你可以给它另外的对象，如：

`s = new StringBuffer("Java");`

这样一来，s就和它指向的第一个对象脱离关系。

由此看来，下面的语句应该不合法吧？至少是没用的吧？

**new Vehicle();**

不对。它是合法的，而且可用的。譬如，如果我们仅仅为了打印而生成一个对象，就不需要用引用变量来系住它。最常见的就是打印字符串：

**System.out.println(“I am Java!”);**

字符串对象“I am Java!”在打印后即被丢弃。有人把这种对象称之为临时对象。

引用可以指向不同的对象，对象也可以被多个引用操纵，如：

`StringBuffer s1 = s;`

这条语句使得s1和s指向同一个对象。既然两个引用指向同一个对象，那么不管使用哪个引用操纵对象，对象的内容都发生改变，并且只有一份，通过s1和s得到的内容自然也一样，(String除外，因为String始终不变，String s1=”AAAA”; String s=s1,操作s,s1由于始终不变，所以为s另外开辟了空间来存储s,)如下面的程序：

```java
StringBuffer s;

s = new StringBuffer("Java");

StringBuffer s1 = s;

s1.append(" World");

System.out.println("s1=" + s1.toString());//打印结果为：s1=Java World

System.out.println("s=" + s.toString());//打印结果为：s=Java World
```

**对象与引用的关系将持续到对象回收。**

**从存储空间上来说，对象和引用是独立的，它们存储在不同的地方，对象一般存储在堆中，而引用存储在速度更快的堆栈中。**

> 参考链接：http://www.cnblogs.com/focusChen/articles/2497768.html

> 声明：本站采用开放的[知识共享署名-非商业性使用-相同方式共享 许可协议](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh)进行许可。
