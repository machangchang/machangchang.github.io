---
layout: post
title: Red-Black-Tree
categories: Java
description: Red-Black-Tree
keywords: Red-Black-Tree
---

## 红黑树

### 二叉查找树

学习红黑树需要先理解二叉查找树。

二叉查找树具有以下特性：

* 1.左子树上所有结点的值均小于或等于它的根结点的值。

* 2.右子树上所有结点的值均大于或等于它的根结点的值。

* 3.左、右子树也分别为二叉排序树。

下图中这棵树，就是一颗典型的二叉查找树：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_001.jpg)

这样的数据结构有什么好处呢？我们试着查找一下值为10的节点。

1. 查看根节点9：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_002.jpg)

2.由于10>9，由此查看右孩子13：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_003.jpg)

3.由于10<13，因此查看左孩子11：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_004.jpg)

4.由于10<11，因此查看左孩子10，发现10正是要查找的节点：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_005.jpg)

这种方式正是二分查找的思想，查找所需的次数等同于二叉树的高度。

在插入节点的时候也是利用类似的方法，通过一层一层比较大小，找到新节点适合插入的位置。

但是二叉树也有缺陷：

假设初始的二叉查找树只有三个节点，根节点值为9，左孩子值为8，右孩子值为12：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_006.jpg)

接下来我们依次插入如下五个节点：7,6,5,4,3。

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_007.jpg)

这样的形态虽然也符合二叉查找树的特性，但是查找的性能大打折扣，几乎变成了线性。

如何解决二叉查找树多次插入新节点而导致的不平衡呢？这时候红黑树就应运而生了。

### 红黑树

红黑树是一种自平衡的二叉查找树，除了符合二叉查找树的基本特性外，它还具有下列的附加特性：

* 1.节点是红色或黑色。

* 2.根节点是黑色。

* 3.每个叶子节点都是黑色的空节点（NIL节点）。

* 4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

* 5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

下图中这棵树，就是一颗典型的红黑树：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_008.jpg)

正是因为这些规则限制，才保证了红黑树的自平衡。红黑树从根到叶子的最长路径不会超过最短路径的2倍。

### 红黑树的调整

当插入或删除节点的时候，红黑树的规则有可能被打破。这时候就需要作出一些调整，来继续维持我们的规则。

什么情况下会破坏红黑树的规则，什么情况下不会破坏规则呢？我们举两个简单的栗子：

1.向原红黑树插入值为14的新节点：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_009.jpg)

由于父节点15是黑色节点，因此这种情况并不会破坏红黑树的规则，无需做任何调整。

2.向原红黑树插入值为21的新节点：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_010.jpg)

由于父节点22是红色节点，因此这种情况打破了红黑树的规则4（每个红色节点的两个子节点都是黑色），必须进行调整，使之重新符合红黑树的规则。

调整方法有两种：**变色**和**旋转**。而旋转又分为两种形式：**左旋转**和**右旋转**。

变色：

为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色。

下图所表示的是红黑树的一部分，需要注意节点25并非根节点。因为节点21和节点22连续出现了红色，不符合规则4，所以把节点22从红色变成黑色：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_011.jpg)

但这样并不算完，因为凭空多出的黑色节点打破了规则5，所以发生连锁反应，需要继续把节点25从黑色变成红色：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_012.jpg)

此时仍然没有结束，因为节点25和节点27又形成了两个连续的红色节点，需要继续把节点27从红色变成黑色：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_013.jpg)

左旋转：

逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。说起来很怪异，大家看下图：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_014.png)

右旋转：

顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。大家看下图：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_015.png)

红黑树的插入和删除包含很多种情况，每一种情况都有不同的处理方式，在这里举一个典型例子。

我们以刚才插入节点21的情况为例：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_016.jpg)

首先，我们需要做的是变色，把节点25及其下方的节点变色：

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_017.jpg)

此时节点17和节点25是连续的两个红色节点，为了维持红黑树的规则，我们把节点8和节点17进行变色，由红色节点编程黑色节点。这样以来就形成了新的红黑树。

![](/images/blog/2018-03-12-Red-Black-Tree/Red_Black_Tree_018.jpg)

> 参考链接：https://zhuanlan.zhihu.com/p/31805309
http://www.cnblogs.com/CarpenterLee/p/5503882.html

