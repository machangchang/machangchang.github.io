---
layout: post
title: 面试-计算机基础-操作系统
categories: 面试
description: 操作系统
keywords: 操作系统
---

### 什么是操作系统？
可以这么说，操作系统是一种运行在内核态的软件。
它是应用程序和硬件之间的媒介，向应用程序提供硬件的抽象，以及管理硬件资源。
![image](https://github.com/user-attachments/assets/a0d7057e-f501-4d7f-8cc7-55cb46439dec)

### 操作系统主要有哪些功能？
操作系统最主要的功能：
处理器（CPU）管理：CPU的管理和分配，主要指的是进程管理。
内存管理：内存的分配和管理，主要利用了虚拟内存的方式。
外存管理：外存（磁盘等）的分配和管理，将外存以文件的形式提供出去。
I/O管理：对输入/输出设备的统一管理。
除此之外，还有保证自身正常运行的健壮性管理，防止非法操作和入侵的安全性管理。
![image](https://github.com/user-attachments/assets/fcfe6b30-27e8-41c1-bd1f-6b96d96fe820)

### 什么是用户态和内核态？
内核具有很⾼的权限，可以控制 cpu、内存、硬盘等硬件，出于权限控制的考虑，因此⼤多数操作系统，把内存分成了两个区域：
内核空间，这个内存空间只有内核程序可以访问；
⽤户空间，这个内存空间专⻔给应⽤程序使⽤，权限比较小；
⽤户空间的代码只能访问⼀个局部的内存空间，⽽内核空间的代码可以访问所有内存空间。因此，当程序使⽤⽤户空间时，我们常说该程序在⽤户态执⾏，⽽当程序使内核空间时，程序则在内核态执⾏。

### 用户态和内核态是如何切换的？
应⽤程序如果需要进⼊内核空间，就需要通过系统调⽤，来进入内核态：
![image](https://github.com/user-attachments/assets/498264a1-f177-40ec-b4b1-3f3212a27dd6)
内核程序执⾏在内核态，⽤户程序执⾏在⽤户态。当应⽤程序使⽤系统调⽤时，会产⽣⼀个中断。发⽣中断后， CPU 会中断当前在执⾏的⽤户程序，转⽽跳转到中断处理程序，也就是开始执⾏内核程序。内核处理完后，主动触发中断，把 CPU 执⾏权限交回给⽤户程序，回到⽤户态继续⼯作。

### 并行和并发有什么区别？
并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器做到的并发，其实是利用时间片的轮转，例如有两个进程A和B，A运行一个时间片之后，切换到B，B运行一个时间片之后又切换到A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。
并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。
![image](https://github.com/user-attachments/assets/7914e9c0-fe47-4d0b-bd85-6479c2661660)

### 什么是进程上下文切换？
对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。上下文切换 (Context Switch) 是一种将 CPU 资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。
![image](https://github.com/user-attachments/assets/7bc1a6d0-066e-40ae-975a-b976af7c4742)

### 进程有哪些状态？
当一个进程开始运行时，它可能会经历下面这几种状态：
运⾏状态（Runing）：该时刻进程占⽤ CPU；
就绪状态（Ready）：可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏；
阻塞状态（Blocked）：该进程正在等待某⼀事件发⽣（如等待输⼊/输出操作的完成）⽽暂时停⽌运⾏，这时，即使给它CPU控制权，它也⽆法运⾏；
![image](https://github.com/user-attachments/assets/8547bccc-0b9c-489c-ab05-361424f68465)
当然，进程还有另外两个基本状态：
创建状态（new）：进程正在被创建时的状态；
结束状态（Exit）：进程正在从系统中消失时的状态；
![image](https://github.com/user-attachments/assets/a17fe925-3b7c-41d1-ac20-09e216a5692e)

### 什么是僵尸进程？
僵尸进程是已完成且处于终止状态，但在进程表中却仍然存在的进程。
僵尸进程一般发生有父子关系的进程中，一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中。

### 什么是孤儿进程？
一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 init 进程 (进程 ID 为 1 的进程) 所收养，并由 init 进程对它们完成状态收集工作。因为孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

### 进程有哪些调度算法？
进程调度就是确定某一个时刻CPU运行哪个进程，常见的进程调度算法有：
![image](https://github.com/user-attachments/assets/223e4288-9800-407f-8556-7f92f348f685)

先来先服务：
非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对I/O密集型进程也不利，因为这种进程每次进行I/O操作之后又得重新排队。
![image](https://github.com/user-attachments/assets/6fa99d94-d2e2-45bc-8748-a5a27a02334e)

短作业优先：
非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。
![image](https://github.com/user-attachments/assets/0508a7d1-11b6-4a5c-9bfd-8e12da006818)

优先级调度：
为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
![image](https://github.com/user-attachments/assets/8333aece-303a-46c4-bd90-42be6b673228)

时间片轮转：
将所有就绪进程按 先来先服务的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。
时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。
![image](https://github.com/user-attachments/assets/fb835c37-e20a-42fd-a27b-d4ae32dcd5aa)

最短剩余时间优先：
最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

### 进程间通信有哪些方式？
![image](https://github.com/user-attachments/assets/01722788-4f08-4915-80fc-d4613653bec4)

每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。

![image](https://github.com/user-attachments/assets/a6777067-1cfc-4c21-ab5b-65afeaacccb7)

#### 管道
如果你学过 Linux 命令，那你肯定很熟悉「|」这个竖线。
$ ps auxf | grep mysql
上面命令行里的「|」竖线就是一个管道，它的功能是将前一个命令（ps auxf）的输出，作为后一个命令（grep mysql）的输入，从这功能描述，可以看出管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才行。
同时，我们得知上面这种管道是没有名字，所以「|」表示的管道称为匿名管道，用完了就销毁。
管道还有另外一个类型是命名管道，也被叫做 FIFO，因为数据是先进先出的传输方式。
在使用命名管道前，先需要通过 mkfifo 命令来创建，并且指定管道名字：
$ mkfifo myPipe
myPipe 就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：
接下来，我们往 myPipe 这个管道写入数据：
$ echo "hello" > myPipe  // 将数据写进管道
你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。于是，我们执行另外一个命令来读取这个管道里的数据：
$ cat < myPipe  // 读取管道里的数据
所谓的管道，就是内核里面的一串缓存。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。
另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。A 和 B 之间不存在父子关系，它俩的父进程都是 shell。
所以说，在 shell 里通过「|」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。
我们可以得知，对于匿名管道，它的通信范围是存在父子关系的进程。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。
另外，对于命名管道，它可以在不相关的进程间也能相互通信。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。
不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的文件定位操作。



